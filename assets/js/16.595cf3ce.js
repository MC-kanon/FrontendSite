(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{294:function(t,n,a){"use strict";a.r(n);var e=a(14),i=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"git基础知识介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git基础知识介绍"}},[t._v("#")]),t._v(" git基础知识介绍")]),t._v(" "),n("ol",[n("li",[t._v("工作区：未被git管理起来的文件。")]),t._v(" "),n("li",[t._v("暂存区：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里。")]),t._v(" "),n("li",[t._v("本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中。")]),t._v(" "),n("li",[t._v("远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；")])]),t._v(" "),n("h2",{attrs:{id:"git配置命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git配置命令"}},[t._v("#")]),t._v(" git配置命令")]),t._v(" "),n("blockquote",[t._v("\n查询配置信息\n")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("列出当前配置："),n("code",[t._v("git config --list")]),t._v(";")])]),t._v(" "),n("li",[n("p",[t._v("列出repository配置："),n("code",[t._v("git config --local --list")]),t._v(";")])]),t._v(" "),n("li",[n("p",[t._v("列出全局配置："),n("code",[t._v("git config --global --list")]),t._v(";")])]),t._v(" "),n("li",[n("p",[t._v("列出系统配置："),n("code",[t._v("git config --system --list")]),t._v(";")])])]),t._v(" "),n("blockquote",[t._v("\n配置用户信息\n")]),t._v('\n1. 配置用户名：git config --global user.name "your name";\n2. 配置用户邮箱：git config --global user.email "youremail@github.com";\n'),n("blockquote",[t._v("\n配置ssh密钥\n")]),t._v("\n1. ssh-keygen -t rsa  生成sshkey\n2. 一直回车使用默认值\n3. 查找公钥\n   1. window系统： C:\\Users\\用户\\\\.ssh\\id_rsa.pub\n   2. MAC系统：命令行输入  cat ~/.ssh/id_rsa.pub\n4. 将公钥加入GitHub的ssh中\n5. 可以使用ssh拉代码啦\n"),n("h2",{attrs:{id:"git境界之练气期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git境界之练气期"}},[t._v("#")]),t._v(" git境界之练气期")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('git init  初始化git管理文件\ngit clone <远程仓库url>     拉取一个远程仓库(适合本地啥都没有的情况)\n\n工作区提交代码到暂存区\ngit add .  提交工作区所有文件到暂存区\n\n暂存区提交到本地仓库\ngit commit -m "版本信息"\n\n本地仓库提交到远程仓库\ngit push <远程仓库别名> <远程仓库分支>\n\n\n查询信息\ngit status  查询当前工作区所有文件的状态\ngit diff    比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容\ngit log 查看提交历史\ngit reflog 查看版本库（查看所有分支的所有操作记录，包括已经删除的）\n\n\n')])])]),n("h2",{attrs:{id:"git境界之筑基期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git境界之筑基期"}},[t._v("#")]),t._v(" git境界之筑基期")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\n暂存区提交到本地仓库\ngit commit -m "版本信息"   \ngit commit -am "版本信息"  相当于add+commit(将git跟踪的文件直接提交版本库，跳过暂存区，注意：新增的文件不会提交)\ngit commit --amend 提交文件时，发现漏掉几个文件可以撤销上一次提交\n\n\n查询信息\ngit diff --cache  比较暂存区与上一版本的差异\n\n打标签（用于特定结点，比如说版本上线）\ngit tag\t\t\t\t\t列出所有标签\ngit tag v1.0\t\t    创建标签\ngit push origin v1.5\t将标签推送到远程仓库中\ngit push origin --tags\t将本地所有的标签全部推送到远程仓库中\n\n分支管理\ngit branch <branch-name>\t  创建分支\ngit checkout <branch-name>    切换到其他分支\ngit checkout -b <branch-name> 新建并切换到新建分支\ngit branch -d <branch-name>   删除分支\ngit merge <branch-name>;\t将当前分支与指定分支进行合并\ngit branch\t\t\t\t   显示本地仓库的所有分支\ngit fetch <remote-name>/<branch-name> 把远程分支拉倒本地(未合并)\ngit merge <remote-name>/<branch-name> 把远程分支合并到当前分支\ngit checkout -b <branch-name> <remote-name>/<branch-name>\n创建新的本地分支并把远程分支设置为当前分支的上游分支（之后可以直接git pull和git push简写操作）\n\n查询信息\ngit remote -v  查看本地仓库关联的远程仓库url地址\ngit remote add [remote-name] [url]  给远程仓库(url地址)取一个名字叫做remote-name\n\n拉取远程仓库分支\n\ngit pull [remote-name] [branch-name]\n')])])]),n("h2",{attrs:{id:"git境界之结丹期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git境界之结丹期"}},[t._v("#")]),t._v(" git境界之结丹期")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("分支管理\n查看上游分支\ngit status 、git checkout <branch>\n设置上游分支\ngit branch --set-upstream-to=origin/main main   给本地main分支设置远程main分支作为上游分支(远程分支存在的情况)\ngit push set-upsteam origin HEAD:main\t远程分支不存在的情况\n取消上游分支\ngit branch --unset-upstream\n\nstash\n分支管理\nmerge\nrebase\n将一个分支里提交的改变移到基底分支上重放一遍：git rebase <rebase-branch> <branch-name>，如git rebase master server，将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用--onto操作：git rebase --onto <rebase-branch> <feature branch> <sub-feature-branch>，如git rebase --onto master server client；使用rebase操作应该遵循的原则是：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作；\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);