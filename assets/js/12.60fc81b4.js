(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{293:function(t,e,a){"use strict";a.r(e);var n=a(14),r=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[t._v("#")]),t._v(" git")]),t._v(" "),e("h2",{attrs:{id:"git基础知识介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git基础知识介绍"}},[t._v("#")]),t._v(" git基础知识介绍")]),t._v(" "),e("ol",[e("li",[t._v("工作区：未被git管理起来的文件。")]),t._v(" "),e("li",[t._v("暂存区：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里。")]),t._v(" "),e("li",[t._v("本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中。")]),t._v(" "),e("li",[t._v("远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；")])]),t._v(" "),e("h2",{attrs:{id:"git配置命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git配置命令"}},[t._v("#")]),t._v(" git配置命令")]),t._v(" "),e("blockquote",[t._v("\n查询配置信息\n")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("列出当前配置："),e("code",[t._v("git config --list")]),t._v(";")])]),t._v(" "),e("li",[e("p",[t._v("列出repository配置："),e("code",[t._v("git config --local --list")]),t._v(";")])]),t._v(" "),e("li",[e("p",[t._v("列出全局配置："),e("code",[t._v("git config --global --list")]),t._v(";")])]),t._v(" "),e("li",[e("p",[t._v("列出系统配置："),e("code",[t._v("git config --system --list")]),t._v(";")])])]),t._v(" "),e("blockquote",[t._v("\n配置用户信息\n")]),t._v('\n1. 配置用户名：git config --global user.name "your name"\n2. 配置用户邮箱：git config --global user.email "youremail@github.com"\n'),e("blockquote",[t._v("\n配置ssh密钥\n")]),t._v('\n1. ssh-keygen -t rsa  生成sshkey\n2. 一直回车使用默认值\n3. 查找公钥\n   1. window系统： C:\\Users\\用户\\\\.ssh\\id_rsa.pub\n   2. MAC系统：命令行输入  cat ~/.ssh/id_rsa.pub\n4. 将公钥加入GitHub的ssh中\n5. 可以使用ssh拉代码啦\n6. 有可能会碰到github说格式不正确的问题，这个时候试一下这两个命令去生成ssh，ssh-keygen -t ed25519 -C "your_email@example.com" 或者 ssh-keygen -t rsa -b 4096 -C "your_email@example.com"\n'),e("h2",{attrs:{id:"git基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git基础"}},[t._v("#")]),t._v(" git基础")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git init  初始化git管理文件\ngit clone <远程仓库url>     拉取一个远程仓库(适合本地啥都没有的情况)\n\n工作区：有变动的文件or新增文件   红色\n缓存区：经过 git add . 绿色\n\n工作区提交代码到暂存区\ngit add .  提交工作区所有文件到暂存区\ngit add <dir> 添加指定目录到暂存区，包括子目录\ngit rm --cached <file>  将file文件从暂存区迁移到工作区 （未跟踪的状态，文件还在）\ngit restore --staged <file>\t 文件从staged -> unstage\ngit rm -f <file>  强制删除文件\ngit checkout -- <filename> 将工作区指定的文件恢复到上次commit的状态\n\n暂存区提交到本地仓库\ngit commit -m "版本信息"\n\n本地仓库提交到远程仓库\ngit push <远程仓库别名> <远程仓库分支>\n\n查询信息\ngit status  查询当前工作区所有文件的状态\ngit diff    比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容\ngit diff --cache <file>  比较暂存区与上一版本的差异\ngit log 查看提交历史\ngit reflog 查看版本库（查看所有分支的所有操作记录，包括已经删除的）\ngit log --pretty=oneline --graph  以图的形式显示版本日志\n')])])]),e("h2",{attrs:{id:"git提高"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git提高"}},[t._v("#")]),t._v(" git提高")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('暂存区提交到本地仓库\ngit commit -m "版本信息"\ngit commit -am "版本信息"  相当于add+commit(将git跟踪的文件直接提交版本库，跳过暂存区，注意：新增的文件不会提交)\ngit commit --amend -m \'***\' 修改上次提交的信息\n查询信息\ngit diff --cache  比较暂存区与上一版本的差异\ngit commit --amend <file1> <file2> 提交文件时，发现漏掉几个文件可以重新提交\ngit commit -v  提交时显示所有diff信息\ngit commit --amend -m \'***\' 修改上次提交的信息\n\n打标签（用于特定结点，比如说版本上线）\ngit tag\t\t\t\t   列出所有标签\ngit tag -d [tag]\t\t删除本地tag\ngit tag v1.0\t\t    创建标签\ngit push <remote> v1.0\t将标签推送到远程仓库中\ngit push <remote> --tags\t将本地所有的标签全部推送到远程仓库中\ngit push <remote> :refs/tags/[tagName]\t删除远程tag\ngit show [tag]\t\t\t查看tag信息\n\n分支管理\ngit branch\t\t\t\t   显示本地仓库的所有分支\ngit branch -r\t\t\t\t 显示远程仓库的所有分支\ngit branch <branch-name>\t  创建分支\ngit checkout <branch-name>    切换到其他分支\ngit checkout -b <branch-name> 新建并切换到新建分支\ngit branch -d <branch-name>   删除本地分支\ngit branch -dr <remote/branch> 删除远程分支（用这个）\ngit push origin --delete [branch-name] 删除远程分支\ngit merge <branch-name>\t将当前分支与指定分支进行合并\n\n查看上游分支\ngit status 、git checkout <branch>、git branch -vv\n设置上游分支\ngit branch --set-upstream-to=origin/main main   给本地main分支设置远程main分支作为上游分支(远程分支存在的情况)\ngit push set-upsteam origin HEAD:main\t远程分支不存在的情况\n取消上游分支\ngit branch --unset-upstream\n\ngit fetch <remote-name> <branch-name> 把远程分支拉倒本地(未合并)\ngit merge <remote-name> <branch-name> 把远程分支合并到当前分支\ngit checkout -b <branch-name> <remote-name> <branch-name>\n创建新的本地分支并把远程分支设置为当前分支的上游分支（之后可以直接git pull和git push简写操作）\n\n查询信息\ngit remote -v  查看本地仓库关联的远程仓库url地址\ngit remote add <remote-name> <url>  给远程仓库(url地址)取一个名字叫做remote-name\ngit remote set-url [--push] <name> <newurl> [<oldurl>] 重新设置远程仓库的url\ngit remote rename origin o  给远程仓库重命名\ngit diff --shortstat "@{0 day ago}"  显示今天你写了多少行代码\n\n拉取远程仓库分支\ngit pull <remote-name> <branch-name>\n\n撤销操作\n版本库—>缓存区（绿色）\tgit reset --soft 版本号（版本号可以用HEAD^来代替，表示上一个版本，撤销commit操作）\n版本库->工作区的tracked位置（红色）    git reset --mix 版本号\n版本库->工作区的untracked位置         git reset --hard 版本号\n缓存区->工作区的tracked位置（红色）    绿变红 git reset HEAD <file>\n\n--soft：仅仅是撤回commit操作，您写的代码仍然保留\n--mixed：不删除工作空间改动代码，撤销commit，并且撤销git add操作\n--hard：删除工作空间改动代码，撤销commit，撤销git add，注意完成这个操作后，就恢复到了上一次的commit状态。\n')])])]),e("h2",{attrs:{id:"git进阶"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git进阶"}},[t._v("#")]),t._v(" git进阶")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git stash 命令会将所有已提交到暂存区，以及没有提交的修改，都进行内部保存，没有将工作区恢复到上一次commit的状态。\ngit stash list  列出所有暂时保存的工作\ngit stash pop   恢复最近一次stash的文件\ngit stash drop  丢弃最近一次stash的文件\ngit stash clear 删除所有的stash\ngit stash apply stash@{1}  恢复某个暂时保存的工作\n\n\n分支管理\nmerge\nrebase\n将一个分支里提交的改变移到基底分支上重放一遍：git rebase <rebase-branch> <branch-name>，如git rebase master server，将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用--onto操作：git rebase --onto <rebase-branch> <feature branch> <sub-feature-branch>，如git rebase --onto master server client；使用rebase操作应该遵循的原则是：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作\n")])])]),e("h2",{attrs:{id:"冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冲突"}},[t._v("#")]),t._v(" 冲突")]),t._v(" "),e("ol",[e("li",[t._v("同一分支下pull或push：比如在同一个分支下，对"),e("strong",[t._v("本地的a文件")]),t._v("做出了"),e("strong",[t._v("修改")]),t._v("，此时我们在进行pull或push时如果"),e("strong",[t._v("远程分支")]),t._v("下的"),e("strong",[t._v("a文件也有修改")]),t._v("，那么代表本地和远程分支的代码是不同步的，此时也会引起冲突。")]),t._v(" "),e("li",[t._v("不同分支下的merge：两个分支下的同一个文件都有修改，这个时候两个分支不同步会产生冲突。")])]),t._v(" "),e("h2",{attrs:{id:"解决冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决冲突"}},[t._v("#")]),t._v(" 解决冲突")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("先将工作区文件暂存，再拉远程代码")]),t._v(" "),e("ol",[e("li",[t._v("git stash")]),t._v(" "),e("li",[t._v("git pull")]),t._v(" "),e("li",[t._v("git stash pop  或者  git stash apply stash@{0}")]),t._v(" "),e("li",[t._v("找到冲突文件并解决")]),t._v(" "),e("li",[t._v("add+commit提交")])])]),t._v(" "),e("li",[e("p",[t._v("提交更改，然后再进行合并")]),t._v(" "),e("ol",[e("li",[t._v('git add . + git commit -m "your commit message"')]),t._v(" "),e("li",[t._v("拉下远程代码手动解决冲突")]),t._v(" "),e("li",[t._v("最后push到远程")])])])]),t._v(" "),e("p",[t._v("最好解决冲突的办法就是：每次写代码之前都从远程仓库拉取最新的代码")]),t._v(" "),e("h1",{attrs:{id:"更新本地代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新本地代码"}},[t._v("#")]),t._v(" 更新本地代码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git fetch upstream   拉下远程代码\ngit rebase upstream/mai  进行变基操作，同步代码\n")])])]),e("h1",{attrs:{id:"git插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git插件"}},[t._v("#")]),t._v(" git插件")]),t._v(" "),e("p",[e("code",[t._v("git graph")])]),t._v(" "),e("p",[t._v("参考目录：")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰-常用 Git 命令清单"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰-ES6入门教程"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://www.bookstack.cn/read/git-tutorial/docs-commands-git-stash.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("书栈网-Git命令大全"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6844903598522908686",target:"_blank",rel:"noopener noreferrer"}},[t._v("git常用命令"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/7021023267028729887",target:"_blank",rel:"noopener noreferrer"}},[t._v("各种工作场景的 git 指令大全"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://www.bookstack.cn/read/liaoxuefeng-git-2020/002dc8c001053b0b.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("廖雪峰Git教程"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6952752045405241358#heading-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试题|git秘籍--多人协作冲突"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6969101234338791432",target:"_blank",rel:"noopener noreferrer"}},[t._v("git rebase，看这一篇就够了"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6844903895160881166",target:"_blank",rel:"noopener noreferrer"}},[t._v("git pull --rebase的正确使用"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);